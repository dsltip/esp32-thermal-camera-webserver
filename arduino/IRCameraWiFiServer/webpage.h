static const char canvas_htm[] PROGMEM = "<!DOCTYPE html><html lang='en'> <head> <meta charset='UTF-8'> <meta name='viewport' content='width=device-width, initial-scale=1.0'> <title>Document</title> <style> * { margin: 0; padding: 0 } .fb { width: 128px; height: 50px } #temperature { padding: 5px; width: 470px; font-size: 1.8em; text-align: center } </style> <script> let startX = 0; let moveX = 10; const positive = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','!','@','#','$','%','^','&','*','(',')','-','_','+','=','9']; const negative = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','<','>','.',',',String.fromCharCode(39),'|','~','`','?',String.fromCharCode(92),'/',':',';','{','}']; const currentPalette = { name: 'FLIR', stops: ['#000000', '#20008C', '#CC0077', '#FFD700', '#FFFFFF'] }; Color = function(hexOrObject) { var obj; if (hexOrObject instanceof Object) { obj = hexOrObject; } else { obj = LinearColorInterpolator.convertHexToRgb(hexOrObject); } this.r = obj.r; this.g = obj.g; this.b = obj.b; this.a = obj.a; }; Color.prototype.asRgbCss = function() { return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.a + ')'; }; var LinearColorInterpolator = { convertHexToRgb: function(hex) { match = hex.replace(/#/, '').match(/.{1,2}/g); return new Color({ r: parseInt(match[0], 16), g: parseInt(match[1], 16), b: parseInt(match[2], 16), a: (hex.length > 7 ? parseInt(match[3], 16) : 255) }); }, findColorBetween: function(left, right, percentage) { newColor = {}; components = ['r', 'g', 'b', 'a']; for (var i = 0; i < components.length; i++) { c = components[i]; newColor[c] = Math.round(left[c] + (right[c] - left[c]) * percentage / 100); } return new Color(newColor); } }; function decompressnew(result) {let pos = result.indexOf('.'); let start = parseInt(result.substring(0, pos)); let output = []; output.push(start/10); let multiplier = 0;let negat = 0; for (let n = pos+1; n < result.length; n += 1) { let found = false; negat = 0; let indexOfItem = positive.indexOf(result[n]); if (indexOfItem === -1) { indexOfItem = negative.indexOf(result[n]); if (indexOfItem >= 0) { found = true; negat = 1; } } else { found = true; } if (!found) { multiplier = parseInt(result[n]) + 1; } else { indexOfItem+= multiplier*41; if(negat>0)start -= indexOfItem*2; else start += indexOfItem*2; output.push(parseFloat(parseFloat(start/10).toFixed(1))); multiplier = 0; } } return output; } function map(value, in_min, in_max, out_min, out_max) { return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; } function getPaletteColor(val, avgLowTemp, avgHighTemp) { if (val <= 0) {const cl = new Color(currentPalette.stops[0]); return `rgba(${cl.r},${cl.g},${cl.b},${cl.a})`; } if (val >= 100) {const cl = new Color(currentPalette.stops[currentPalette.stops.length - 1]); return `rgba(${cl.r},${cl.g},${cl.b},${cl.a})`; } const stopsCount = currentPalette.stops.length - 1; const relevantStop = Math.floor(val / (100 / stopsCount)); const left = new Color(currentPalette.stops[relevantStop]); const right = new Color(currentPalette.stops[relevantStop + 1]); const percentage = map(val, relevantStop * (100 / stopsCount), (relevantStop + 1) * (100 / stopsCount), 0, 100); const cl = LinearColorInterpolator.findColorBetween(left, right, percentage); return `rgba(${cl.r},${cl.g},${cl.b},${cl.a})`; } function interpolateData(input, rowLength) { const output = []; let rowNum = 1; for (let n = 0; n < input.length; n += 1) { if (n % rowLength === 0) { output.push((input[n] + input[n + 1]) / 2) } else if (n > 0) { output.push((input[n] + input[n - 1]) / 2) } else { output.push(input[n]); } if ((n + 1) % rowLength === 0) { if (input.length - n > rowLength) { for (let r = 1; r <= rowLength * 2 - 1; r++) { const roundedA = ((rowNum - 1) * rowLength) + Math.floor((r - 1) / 2); const roundedB = ((rowNum - 1) * rowLength) + Math.floor((r - 1) / 2); const topA = input[roundedA]; const topB = input[roundedB]; const roundedC = (rowNum * rowLength) + Math.floor((r - 1) / 2); const roundedD = (rowNum * rowLength) + Math.floor((r - 1) / 2); const bottomA = input[roundedC]; const bottomB = input[roundedD]; output.push((topA + topB + bottomA + bottomB) / 4); } rowNum += 1; } } else { output.push((input[n] + input[n + 1]) / 2) } } return output; } var AScale = 1; let url = 'ws://thermal.local:81'; if (typeof ipAddress !== 'undefined') { url = 'ws://' + ipAddress + ':81'; } let connection = new WebSocket(url); connection.onopen = function() { connection.send('Ping'); }; connection.onerror = function(error) { console.log('WebSocket Error ' + error); }; let avgHighTemp = 0; let avgLowTemp = 0; let avgTemp = 0; let high = -100; let low = 200; let counter = 30; connection.onmessage = function(e) { if (e.data.length < 100) { return; } const values = decompressnew(e.data); const tempValues = interpolateData(values, 32);let sortedValues = values;sortedValues.sort(function(a, b) { return a - b;}); avgTemp = 0; for (let w = 0; w < sortedValues.length; w += 1) { avgTemp += sortedValues[w]; }avgTemp = avgTemp / sortedValues.length; avgHighTemp = 0; for (let w = sortedValues.length - 3; w > sortedValues.length - 10; w -= 1) { avgHighTemp += sortedValues[w]; } avgHighTemp = avgHighTemp / 7; avgLowTemp = 0; for (let w = 4; w < 24; w += 1) { avgLowTemp += sortedValues[w]; } avgLowTemp = avgLowTemp / 20; if (counter >= 20) { let avgTempF = avgTemp; avgTempF = parseInt(avgTempF * 10) / 10; let avgHighTempF = avgHighTemp; avgHighTempF = parseInt(avgHighTempF * 10) / 10; let avgLowTempF = avgLowTemp; avgLowTempF = parseInt(avgLowTempF * 10) / 10; let lowF = parseInt(low * 10) / 10; let highF = parseInt(high * 10) / 10; document.getElementById('temperature').innerText = 'Low: ' + avgLowTempF + ' | High: ' + avgHighTempF + ' | Avg: ' + avgTempF + ' ('+ lowF +','+highF+')'; counter = 0; return; } counter += 1;if(AScale>0){ if (Math.abs(low - avgLowTemp) < 1.5) {} else if (low === 200) { low = avgLowTemp; } else if (low > avgLowTemp) { low -= 1; } else if (low < avgLowTemp) { low += 1; } if (Math.abs(high - avgHighTemp) < 1.5) {} else if (high === -100) { high = avgHighTemp; } else if (high > avgHighTemp) { high -= 1; } else if (high < avgHighTemp) { high += 1; }}; var c2 = document.getElementById('myCanvas'); var c2_context = c2.getContext('2d');var tcolor=''; let xPos = startX; let yPos = 0; for (let i = 0; i < tempValues.length; i += 1) { let value = ((tempValues[i] - low) / (high - low)) * 100; let tcolor = getPaletteColor(value, low, high); c2_context.fillStyle = tcolor; c2_context.fillRect(xPos, yPos, 10, 10); yPos += 10; if (i > 0 && (i + 1) % 63 === 0) { xPos += moveX; yPos = 0; } } }; function flip() {AScale = 1 - AScale; }; </script> </head> <body> <canvas id='myCanvas' width='470' height='630' style='border:1px solid #d3d3d3;'></canvas> <p id='temperature'></p> <button class='fb' onclick='low-=5;high+=5;'>-</button> <button class='fb' onclick='flip()'>Auto</button> <button class='fb' onclick='low+=5;high-=5;'>+</button> <p id='ip'></p> </body> <script> if (typeof ipAddress !== 'undefined') { document.getElementById('ip').innerText = 'IP: ' + ipAddress; } </script></html>";
